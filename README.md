# 仓库说明
## 内容描述
本仓库为牛客网剑指offer题目的刷题记录，网址为：https://www.nowcoder.com/ta/coding-interviews ，[点击跳转到剑指offer](https://www.nowcoder.com/ta/coding-interviews)
每个题的代码放在src中，在main.cpp引入对应类的头文件，然后运行测试函数即可，例如需要运行题1时，对main.cpp写成如下形式即可:
~~~ c++
#include <iostream>
#include "src/P01_2d_array_find.h"

using namespace std;

int main() {
    P01_2d_array_find G;
    G.test();
    return 0;
}
~~~
然后点击运行即可。

## 刷题日志
|<center>题号</center>|<center>题目名</center>|<center>完成日期</center>|<center>描述</center>|<center>备注</center>|
:-:|:-:|:-:|:-|:-
|P01|二维数组的查找|2019.9.10|问题：在一个递增的二维数组中查找一个数是否存在。<br>思路：从左上角或者右上角开始查找|思考递减数组|
|P02|替换空格|2019.9.10|问题：将空格替换为%20。<br>思路：从后往前替换，避免移动，时间复杂度O(n)|小换大，从后往前<br>大换小，从前往后|
|P03|从尾到头打印链表|2019.9.10|问题：将链表从尾到头存放到vector中<br>思路：顺序遍历，然后对vector进行反转|不建议反转链表，会改变链表结构|
|P04|重建二叉树|2019.9.10|问题：根据前序和中序递归构建二叉树<br>思路：递归构建二叉树|复习时要回顾这个题
|P05|用两个栈实现队列|2019.9.11|问题：用两个栈实现队列的push和pop操作<br>思路：push时，直接存入stack1；pop时，若stack2不为空，则直接弹出栈顶元素，否则，将stack1放入stack2，再弹出栈顶元素。|无
|P06|旋转数组的最小数字|2019.9.11|问题：数组旋转一次后，找出数组的最小值<br>思路：用双指针的二分查找方法|不要顺序遍历|
|P07|斐波那契数列|2019.9.11|问题：输出斐波那契数列的第n项<br>思路：递归计算时间空间复杂度过大，用非递归做，F(n)=F(n-1)+F(n-2)|用非递归方法|
|P08|跳台阶|2019.9.11|问题：计算跳上number级台阶的跳法数量<br>思路：递归计算时间空间复杂度过大，用非递归做，F(n)=F(n-1)+F(n-2)|用非递归方法|
|P09|变态跳台阶|2019.9.11|问题：计算跳上number级台阶的跳法数量，每次可以选择跳1-n级<br>思路：利用数学归纳法推导，F(n)=2*F(n-1)|用非递归方法|
|P10|矩形覆盖|2019.9.11|问题：用2\*1的矩形去覆盖2\*number的大矩形，计算覆盖的方法数<br>思路：这个题也是斐波拉契数列，F(n)=F(n-1)+F(n-2)|用非递归方法|
|P11|二进制中1的个数|2019.9.11|问题：给定一个整数，计算其二进制中1的个数<br>思路：介绍了3种方法，关键是第2和第3种。方法1,采用每次右移n，提前处理负数；方法2采用每次将flag左移；方法3采用n=n&(n-1)的方式计算|掌握3种方法
|P12|数值的整数次方|2019.9.12|问题：不用库函数，计算base的exponent次方<br>思路：考虑两个点，一是int的绝对值算法，考虑边界值,使用unsigned int处理；二是0的处理，返回0|绝对值的处理|
|P13|调整数组顺序使奇数位于偶数前面|2019.9.12|问题：将一个数组的奇数放在前面，偶数放在后面，奇数之间、偶数之间的相对位置不变<br>思路：可以采用双指针平移的做法，排序的做法，用两个vector组合做法都可以|如果只要求奇数前，偶数后，则用双指针做法|
|P14|链表中倒数第k个结点|2019.9.13|问题：输出该链表中倒数第k个结点<br>思路：利用双指针思想，指针1先走k步，之后指针2与指针1同步移动，直到链表结尾|考虑0，空链表，倒数第x个，倒数第1个，倒数第length个等情况|
|P15|反转链表|2019.9.13|描述：将链表进行反转后，然后输出新链表的表头<br>思路：使用三个指针，分别指向前，中，后三个位置，中表示正在处理的节点|常见题，注意多复习|
|P16|合并两个排序的链表|2019.9.13|描述：将两个有序链表合并成一个有序链表<br>思路：使用一个指针，先构建头结点，然后再逐个构建起一条链表，类似于新建链表的过程|常见题，注意多复习<br>用非递归实现的，而书上使用的是递归方法，但本质是一样的|
|P17|树的子结构|2019.9.13|描述：判断树B是不是树A的子结构<br>先找到一个节点值相等的节点，然后再递归进行计算，如果不包含，再在左右子树中找相等的节点。 HasSubtree，找到一个相等的节点；DoesTree1HaveTree2，开始计算两个树是否包含。|常见题，注意多复习
